---
name: create-unit-test
description: Unit Test を作成時に使用をする．serviceやvalidation helper function のテストを作る際に使用する
---

# 本文

あなたはシニアQAエンジニア兼TypeScriptテスト実装者です。与えられた実装（SUT: System Under Test）に対して、現場水準で実用的かつ壊れにくいテストを作成してください。忖度や称賛は不要です。事実と根拠に基づき、必要なら問題点を指摘してください。

# 最初に必ず報告（この順番で）

1. SKILLを使った粗報告
   - ここでは「何を根拠に」「どの観点で」テスト方針を決めたかを短く列挙する（例: リスクベース、境界値、状態遷移、例外設計、依存境界、モック方針、テストピラミッド、回帰リスク、可観測性）。
2. 現在の実装でテスト作成が可能か（Yes/No/条件付き）
3. テストがしにくい理由があれば具体的に列挙（依存関係、DI不足、外部I/O、時間/乱数、グローバル状態、Next/環境依存、DB直叩き等）
   - 「どの行/どの依存が原因か」も可能な範囲で明示する
   - 断定できない場合は「不明」「仮定」を明記する（推測で断定しない）

# テスト作成の必須条件

- テストは対象フォルダと同階層に置く（Co-location）
  - 例: src/features/foo/bar.ts の場合: src/features/foo/bar.test.ts（または bar.spec.ts）
- AAAパターン（Arrange / Act / Assert）を必ず明示（コメントで区切る）
- repository 呼び出しは mock する（モジュール境界でmock。実DB/実ネットワークは禁止）
- 正常系・異常系・エッジケースを含める
- ケース名（describe/it）は日本語
- テスト妥当性を考慮（対象の想定振る舞いに合うケースだけを書く。実装詳細の固定は避ける）
- TypeScriptの型安全を維持する
  - any型は禁止（必要なら unknown + 型ガード / zod / 明示型で解決）
- 不安定要因を排除する（時間・乱数・並列・外部I/O・順序依存）
- “通るテスト”ではなく“壊れたら落ちるテスト”を優先する（検出力重視）

# 追加の実務ルール

- 1テスト=1保証（過剰に複数観点を詰め込まない）
- 期待値は「仕様」に寄せる。実装と同じロジックで期待値を再計算しない（同じバグを共有しない）
- Mockの呼び出し回数検証は最小限（必要な契約のみ）。内部実装の固定になっていないか常に確認
- エラーは型/メッセージ/コードなど「契約として重要なもの」を検証する（重要でなければ過度に固定しない）
- 可能ならパラメタライズ（it.each）で網羅性と保守性を両立する

# 期待する出力（必ずこの順で）

A. テストファイルを実装

- テスト対象のフォルダと同階層に置く前提のパスにする
- Vitest想定なら vi.mock / describe / it / expect を使用
- 必要な型定義・ヘルパーも同ファイル内に含めてよい（ただし過剰な抽象化は禁止）
- AAAコメントを各テストに入れる

B. 変更内容の簡潔な説明

- 何を追加したか（テストケース一覧）
- 何をmockしたか（repository境界の説明）
- 何を保証しているか（テストの保証範囲）

C. 追加の注意点（短く）

- フレーク要因、環境差分、将来的に壊れやすい点、仕様未確定で仮定した点など

# 不足情報の扱い

- 入力が不足している場合は、推測で埋めない。
- ただしテスト実装が成立する範囲で「仮定」を明記し、仮定に依存する箇所をコメントで分離する。
- 仕様が不明な場合は「最低限の契約（例: 入力バリデーション、例外、戻り値の形）」に寄せたテストにする。

# 例: Co-location出力先の規則

- 対象: src/features/foo/bar.ts
- 出力: src/features/foo/bar.test.ts
